---
title: Filters and Shortcodes
format: revealjs
---

# What are filters?

## What are filters?

![](images/pandoc-step.jpg){.r-stretch}

Filters manipulate the AST between the parsing and the writing phase. First, understand the AST.

::: footer
<https://pandoc.org/lua-filters.html>
:::

## [AST: A document is composed of `Blocks`]{.small}

::: {.columns}
::: {.column}
```{.markdown .wrap filename="example.qmd"}
{{< include _ast-diagrams/ast-1.qmd >}}
```
:::
::: {.column}
![](images/ast-1-blocks.png){}
:::
:::

:::{.notes}
Dive into the AST in increasing level of detail.

A document is composed of a series of blocks.

In the AST diagram, blocks stack vertically. 

At the top-level this document has a `Para` block followed by a `Div` block.

Some blocks can contain other blocks, like this `Div` contains two `Para` blocks. 


:::

## [AST: Some `Blocks` contain other `Blocks`]{.small}

::: {.columns}
::: {.column}
```{.markdown .wrap filename="example.qmd"}
{{< include _ast-diagrams/ast-1.qmd >}}
```
:::
::: {.column}
![](images/ast-1-blocks-highlight.png){}
:::
:::

## [AST: Some `Blocks` contain `Inlines`]{.small}

::: {.columns}
::: {.column}
```{.markdown .wrap filename="example.qmd"}
I **really** like bold and *really* like italics, and *really **really*** can't decide which to use.

...
```
:::
::: {.column}
![](images/ast-1-inlines-para-1.png){}
:::
:::

:::{.notes}
Blocks can also contain `Inlines`. 

In the AST diagram, inlines flow horizontally.

This first `Para` block contains a series of `Inline` elements.

The most basic are `Str` and `Space`. 

Inlines can also contain other inlines.
E.g. a `Strong` that contains a single `Str`, an `Emph` that contains a `Str`, `Space` and `Strong`.

`Str` and `Space` can't contain anything else, so are often collapsed in diagrams. 
:::

## [AST: Diagrams might collapse `Str` and `Space`]{.small}

::: {.columns}
::: {.column}
```{.markdown .wrap filename="example.qmd"}
{{< include _ast-diagrams/ast-1.qmd >}}
```
:::
::: {.column}
![](images/ast-1-inlines.png){}
:::
:::

:::{.notes}
Why is this useful? 

1. To offer new output formats, Pandoc just needs a writer that converts the AST to that format.

2. We can describe transformations of the document in a format independent way.

:::

## [A filter function transforms a type of node]{.small}

E.g. `Emph` (TODO: fix screenshots to match example) 

::: {.columns}
::: {.column width="35%"}
::: {.r-stack}
![](images/ast-1-inlines.png){}

![](images/filter-one-strong.jpg){.fragment}
:::
:::
::: {.column width="30%"}
::: {.r-stack}
![](images/filter-input.jpg){.fragment}

![](images/filter-input-output.jpg){.fragment}

:::
:::
::: {.column width="35%"}
![](images/filter-one-emph.jpg){.fragment}
:::
::: 


:::{.notes}
A function called on every instance of that type of node

The input to the function is the node itself

The output of the function replaces the node
::: 


## Output can be ... a single node of the same kind 

E.g. A single `Inline`

## Output can be ... an array of nodes of the same kind 

E.g. An array of `Inline`, a.k.a an `Inlines`

## Output can be ... an empty array 


## Output can be ... `nil`


## AST and filter review

A document is an array of `Block` elements (e.g. `Para`, `Div`)

Some `Block` elements contain other `Block` elements (e.g. `Div` can contain `Para`)

Some `Block` elements contain `Inline` elements (e.g. `Para` contains `Str`)

Some `Inline` elements contain other `Inline` elements (e.g. `Emph` contains `Str`, `Space`, `Strong`)

A filter function is called on every instance of a particular type of node.

The input is the node itself, the output replaces the node.

## Your Turn {.smaller}

Take a look at the AST diagram on the next slide. 

*   What are some other types of `Block` nodes?

*   What are some other types of `Inline` nodes?

*   If we wrote a filter for `Para`, how many times would it be called?

*   If we wrote a filter for `Str`, which of the following would be affected?
    
    * The text `Introduction` in the heading
    * The text `Lua` in the link text 
    * The text `lua-filters` in the link URL
    * the text `quarto` in the code block

{{< countdown "6:00" >}}

## AST

[View Full Screen](_ast-diagrams/your-turn-1-ast.html)

```{=html}
<iframe src="_ast-diagrams/your-turn-1-ast.html" class = "ast-diagram"></iframe>
```

## Solution {visibility="hidden"}

* Other `Block` nodes: `Header`, `BulletList`, `CodeBlock`

* Other `Inline` nodes: `Link`, `Image`, `Code`

* A filter function for `Para` would be called four times.

* Affected by a `Str` filter function?

    * The text `Introduction` in the heading. **Yes**
    * The text `Lua` in the link text. **Yes**
    * The test `lua-filters` in the link URL. **No**
    * The text `quarto` in the code block. **No** 

{{< countdown "6:00" >}}

## Filter examples



# Writing filters

## Writing filters

Filters are written in the programming language [Lua](https://www.lua.org/).

A **filter** is a Lua file that contains one or more filter functions.

A **filter function** is a function whose name is a type of node.

## A filter function on `Emph` nodes

::: {.columns}
::: {.column}
Define a function named `Emph`:

```{.lua filename="no-change.lua"}
Emph = function(el)
  return nil
end
```   
:::
::: {.column  .fragment}
To use the filter, specify it in the document header:

```{.yaml filename="example.qmd"}
---
title: "Filter Basics"
filters:
  - no-change.lua
---
```
:::
:::

[A filter function that returns `nil`, leaves the node unchanged.]{.fragment}

::: {.aside}
TODO: give path to example code
:::

## "Print" debugging 

::: {.columns}
::: {.column}
```{.lua filename="no-change.lua" code-line-numbers="2,3"}
Emph = function(el)
  quarto.log.output("Here!")
  quarto.log.output(el)
  return nil
end
```

`quarto.log.output()`: Positron/VS Code look in Terminal, RStudio look in Background Jobs.

:::
::: {.column}
*  `Emph` filter function is called twice.
* `el` is an `Emph` object, an example of an `Inline`. 
* `el` contains a `content` field which is an `Inlines`.
:::
::: 

::: aside
<https://pandoc.org/lua-filters.html#type-emph>
:::

## Replace italic text with bold text

::: {.columns}
::: {.column}
```{.lua filename="replace-emph.lua"}
Emph = function(el)
  return pandoc.Strong(el.content)
end
```   
:::
::: {.column}
* [`pandoc.Strong()`](https://pandoc.org/lua-filters.html#pandoc.Strong) creates a `Strong` node another example of an `Inline` node.
* `el.content` gets the `content` field from the `el` object.
:::
:::

## Other similar types of `Inline` elements

| Type             | Constructor | Fields |
|------------------|-------------|--------|
| Emph | `pandoc.Emph(content)` | `content`  |
| SmallCaps | `pandoc.SmallCaps(content)` | `content`  |
| Strikeout | `pandoc.Strikeout(content)` | `content`  |
| Strong | `pandoc.Strong(content)` | `content`  |
| Subscript | `pandoc.Subscript(content)` | `content`  |
| Superscript | `pandoc.Superscript(content)` | `content`  |
| Underline | `pandoc.Underline(content)` | `content`  |
| Quoted | `pandoc.Quoted(quotetype, content)`,  `quotetype`: `SingleQuote` or `DoubleQuote` | `quotetype`, `content` |

`content` is an `Inlines` object (a list of `Inline` elements).

## Your Turn

1. Write a filter, `replace-bold.lua`, that turns all bold text to underlined text.

2. Add the `Emph` filter function from `replace-emph.lua` to `replace-bold.lua`. What happens?

**Other challenges**: 

* Write a filter that removes all bold and italic formatting, leaving just the text.

* Write a filter that converts all double quotes to single quotes.

{{< countdown "10:00" >}}

## Solution {visibility="hidden"}

```{.lua filename="replace-bold.lua"}
Strong = function(el)
  return pandoc.Underline(el.content)
end
```  


## Solution {visibility="hidden"}

```{.lua filename="replace-double-quotes.lua"}
Quoted = function(el)
  if el.quotetype == "DoubleQuote" then
    return pandoc.Quoted("SingleQuote", el.content)
  end
end
```

## Valid return values

A filter on an `Inline` must return either:

* `nil`, node is unchanged, e.g. `no-change.lua`
* an `Inline` which replaces the original, e.g. `replace-emph.lua`
* a list of `Inline` (known as an `Inlines`)  which replaces the original, spliced into its siblings.

::: {.aside}
For `Block` elements, replace `Inline` with `Block`, and `Inlines` with `Blocks`.
:::


## An `Inlines` with three elements

::: {.columns}
::: {.column}
```{.lua .wrap filename="double-emph.lua"}
Emph = function(el)
  return pandoc.Inlines({
    el, 
    pandoc.Space(), 
    el
  })
end
```  
:::
::: {.column}
> I **really** like bold and *really* *really* like italics, and *really **really*** *really **really*** can't decide which to use.
:::
:::


## An empty list 

::: {.columns}
::: {.column}
```{.lua filename="remove-emph.lua"}
Emph = function(el)
  return {}
end
```
:::
::: {.column}
> I **really** like bold and like italics, and can't decide which to use.
:::
::: 

::: aside

Link to something that explains LUA tables

:::


## Common mistake: an array of `Inlines`

This won't work because `el.content` is an `Inlines` object:

```{.lua}
return pandoc.Inlines({el.content, el.content})
```
  
```{.default}
Error running filter /Applications/quarto/share/filters/main.lua:
Inline expected, got Inlines
```

Useful pattern: create an empty `Inlines` object, then use `insert` for `Inline`, and `extend` for `Inlines`:

```{.lua}
local result = pandoc.Inlines({})
result:extend(el.content)
result:insert(pandoc.Str(" "))
result:extend(el.content)
return result
```

::: aside

Works with `Blocks` too.

:::

# Targeting specific content 

## Targeting specific content 

```{.markdown .wrap filename="target-span.qmd"}
---
title: "Filter Basics"
filters:
  - shout.lua
---

I **really** like bold and *really* like italics, and *really **really*** can't decide which to use.

[And sometimes I **really** need to shout]{.shout}
```


![](images/ast-target-span.png){}


::: aside
TODO: show path for example
::: 

## Smallcaps all spans with class `shout`

::: {.columns}
::: {.column}
```{.lua filename="shout.lua"}
Span = function(el)
  if el.classes:includes("shout") then
    return pandoc.SmallCaps(el.content)
  end  
end
```
:::
::: {.column}

* Classes are in `el.classes` (also `el.identifier` and `el.attributes`).

* `includes()` is a method on Pandoc lists <https://pandoc.org/lua-filters.html#methods-2>

:::
::: 


## Constructing content in a filter

::: {.columns}
::: {.column}
```{.lua filename="shout.lua"}
Span = function(el)
  if el.classes:includes("shout") then
    local result = pandoc.Inlines({})
    result:extend(el.content)
    result:insert(pandoc.Str("!"))
    return result
  end  
end
```
:::
::: {.column}
A useful pattern:

* Create an empty `Inlines` object
* Use `extend()` to add `Inlines` 
* Use `insert()` to add `Inline`
:::

::: 


::: aside 
Works with `Block`/`Blocks` too.
:::

## Your turn: [Simon says](https://en.wikipedia.org/wiki/Simon_Says) {.smaller}

Complete `says.lua`, a filter that:

* targets `Span` elements with class `says`, and 
* turns them into "Simon says" instructions. 

::: {.columns}
::: {.column}
E.g. source:
```{.markdown filename="Before"}
[Write a filter]{.says}
``` 
:::
::: {.column}
Becomes equivalent to:
```{.markdown filename="After"}
Simon says "Write a filter"
```
:::
:::

**Challenge:** Instead of `Simon`, let the user specify the name as an attribute, e.g. `[Write a filter]{.says name="Charlotte"}`

## Solution {visibility="hidden"}

```{.lua filename="says.lua"}
Span = function(el)
  if el.classes:includes("says") then
    result = pandoc.Inlines({})
    result:insert(pandoc.Str("Simon says "))
    result:insert(pandoc.Quoted('DoubleQuote', el.content))
    return result
  end
end
```

# Filters in practice

<!-- give example code/pseudo code mostly for reference -->

## Target content in a div

::: {.columns}
::: {.column width="40%"}
````{.markdown .wrap filename="target-div.qmd"}
---
title: "Filter Basics"
filters:
  - shout.lua
---

::: {.shout}
And sometimes I **really** need to shout

```r
library(scream)
```
:::
````

:::
::: {.column width="60%"}
```{.lua filename="shout.lua"  code-line-numbers="|1,5"}
Div = function(el)
  if not el.classes:includes("shout") then
    return nil
  end
  local result = pandoc.Blocks({})
  -- Transform el, construct result
  return result 
end
```
:::
::: 


::: footer

Example: `03-filters/examples/4-filters-in-practice/1-target-content-in-div`

:::

## [Use `walk` to apply filter functions to children]{.small}

::: {.columns}
::: {.column width="40%"}
````{.markdown .wrap filename="target-div.qmd"}
---
title: "Filter Basics"
filters:
  - shout.lua
---

::: {.shout}
And sometimes I **really** need to shout

```r
library(scream)
```
:::
````
:::
::: {.column width="60%"}
```{.lua filename="shout.lua"  code-line-numbers="|5-9"}
Div = function(el)
  if not el.classes:includes("shout") then
    return nil
  end
  result = el:walk({
    Str = function (el) 
      -- filter function on Str
    end
  })
  return result.content
end
```
:::
::: 

<https://pandoc.org/lua-filters.html#type-pandoc:walk>

::: footer

Example: `03-filters/examples/4-filters-in-practice/2-walk-children-nodes`

:::

## Construct format specific output

::: {.columns}
::: {.column width="40%"}
````{.markdown .wrap filename="example.qmd"}
---
title: "Format-Specific Output"
format: pdf
filters:
  - shout.lua
---

::: {.shout}
And sometimes I **really** need to shout

```r
library(scream)
```
:::
````
:::
::: {.column width="60%"}
```{.lua filename="shout.lua" code-line-numbers="|6,8"}
Div = function(el)
  if not el.classes:includes("shout") then
    return nil
  end

  if quarto.format.is_latex_output() then
    local result = pandoc.Blocks({})
    -- use `pandoc.RawBlock('latex', )`
    return result
  end
  
end
```
:::
::: 


::: footer

Example: `03-filters/examples/4-filters-in-practice/3-format-specific-output`

:::

## [Filter function on `Meta` to examine metadata]{.small}

::: {.columns}
::: {.column }
```{.markdown .wrap filename="article.qmd"}
---
author:
  - name: Mine Çetinkaya-Rundel
    orcid: 0000-0001-6452-2420
    email: mine@posit.co
    affiliations:
      - name: Duke University
      - name: Posit, PBC
  - name: Charlotte Wickham
    orcid: 0000-0002-6365-5499
    email: charlotte.wickham@posit.co
    affiliation:
      - name: Posit, PBC
---
```
:::
::: {.column}
```{.lua filename="meta.lua"}
Meta = function(meta)
  quarto.log.output(meta)
end
```
:::
::: 


::: footer

Example: `03-filters/examples/4-filters-in-practice/4-meta-filter`

:::

## [Controlling the order of filter functions]{.small}

::: {.columns}
::: {.column}
Filter functions in the same filter are run in a [specific order](https://pandoc.org/lua-filters.html#typewise-traversal): `Inline` elements, `Inlines()`, `Block` elements, 
`Blocks()`,  `Meta()`, `Pandoc()`.

Specify a different order by returning an array of **filter sets**.

:::
::: {.column}
```{.lua filename="meta.lua" code-line-numbers="|4-6,9-11|2,3,7,8,12,13"}
local string_out = ""
return {
  { -- this set is run first
    Meta = function (meta)
      -- store `string_out`
    end
  },
  { -- this set is run second
    Div = function(el)
      -- use `string_out`
    end
  }
}
```
:::
::: 


::: footer

Example: `03-filters/examples/4-filters-in-practice/5-filter-sets`

:::

## Controlling when a filter runs

::: {.columns}
::: {.column}
Quarto's internal filters are grouped and run in sequence: `ast`, `quarto`, `render`.

By default, custom filters are run `pre-quarto`. 

You might need to run a filter later, e.g. after quarto has processed cross-references.
:::
::: {.column}
You can specify with `at` e.g:

```{.yaml filename="example.qmd"}
filters:
  - at: post-quarto
    path: shout.lua
```

Also `pre-ast`, `post-ast`, `pre-render`, `post-render`
:::
::: 

::: footer
Filter sequence in source: 
<https://github.com/quarto-dev/quarto-cli/blob/main/src/resources/filters/main.lua>
:::

# Wrapping Up

## Filter extensions

`quarto create extension filter` creates boilerplate. Drop your `.lua` files in. 

::: {.columns}
::: {.column}
```{.default filename="shout/"}
├── README.md
├── _extensions
│   └── shout
│       ├── _extension.yml
│       └── shout.lua
└── example.qmd
```
:::
::: {.column}
```{.yaml filename="_extension.yml"}
title: Shout
author: Charlotte Wickham
version: 1.0.0
quarto-required: ">=99.9.0"
contributes:
  filters:
    - shout.lua
```
:::
::: 


Users must opt-in to extension under `filters`:

```{.markdown .wrap filename="example.qmd"}
---
filters:
  - shout
---
```


::: footer
<https://quarto.org/docs/extensions/filters.html#filter-extensions>
:::

## Filters in custom format extensions

::: {.columns}
::: {.column}
```{.default filename="shouty/"}
├── README.md
├── _extensions
│   └── shouty
│       ├── _extension.yml
│       └── shout.lua
└── template.qmd
```
:::
::: {.column}
```{.yaml filename="_extension.yml"}
title: Shouty
author: Charlotte Wickham
version: 1.0.0
quarto-required: ">=99.9.0"
contributes:
  formats:
    html:
      filters:
        - shout.lua
```
:::
::: 

Users specify `format: shouty-html`, and get filter applied automatically.

## Shortcodes

Lua functions that insert their output into the AST.

::: {.columns}
::: {.column}
````{.markdown .wrap filename="hello.qmd" shortcodes="false"}
---
shortcodes:
  - hello.lua
---

{{< hello >}}

````
:::
::: {.column}
```{.lua filename="hello.lua"}
hello = function ()
  return pandoc.Str("Hi there!")
end
```
:::
::: 

Can take arguments: `args`, `kwargs`, `meta`, `raw_args`, `context`

::: footer
<https://quarto.org/docs/extensions/shortcodes.html>
:::

# Questions? {.r-fit-text .center}

## 

::: {.callout-caution}

## AST diagrams are WIP

The AST diagrams you've seen are produced using Pandoc's version of markdown.

Quarto specific features won't appear in the AST diagrams as you might expect. E.g. cross-references, executable code blocks (ones with `{`), shortcodes, callouts, etc..

Use `quarto.log.output()` to examine the AST as it is when your filter is run.

This will improve!
:::
